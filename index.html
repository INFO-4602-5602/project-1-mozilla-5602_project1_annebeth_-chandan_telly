
<!DOCTYPE html>
<meta charset="utf-8">
<style>
/*
TODO: Use this? */
@import url(//fonts.googleapis.com/css?family=Oswald:400);

body {
  /* font-family: 'Roboto Slab', 'Helvetica Neue', Helvetica, Arial, sans-serif */
  font-family: "Oswald", sans-serif;
}

p {
  padding: {top: 20, right: 0, bottom: 20, left: 0};
}

</style>

<body>
<!--Import the D3 Library (version 4 in this case)-->
<script src="https://d3js.org/d3.v4.min.js"></script>

<h1>Something about users and their devices</h1>
<p>
  We are almost there! Now we just have to do some final cleaning up and making things look good.
</br>
  TO-DOs:
  <ul>
    <li> Update preprocessing: remove spaces from devices per user category [Annebeth]
    <li> Writing the README [Annebeth]
    <li> Add some more comments to the code [Annebeth]
    <li> Styling of the visualizations? For example, fonts on plots, label size, etc. [Nishank?]
    <li> In the tooltips on the barplot, instead of just the simple count, show the percentage
      of users (in other words, the value of the bar segment divided by the value of the associated
      square in the heatmap.
    <li> Clean up the Github folder.
  </ul>
</p>
<p>
  Lorem ipsum and other things.
</p>
<div id="visualization_1"></div>
<p>
  Click on a square in the heatmap to see the associated user counts in the
  barplot. Click the same square again to go back to the barplot with overall
  counts.
</p>
<div id="visualization_2"></div>

<script>
  // VISUALIZATION 1: HEATMAP
  // Set up the bounds of the visualization
  var margin = { top: 20, right: 40, bottom: 30, left: 100 };
  var width = 600 - margin.right - margin.left;
  var height = 450 - margin.top - margin.bottom;

  // Set up the first SVG that gives us a canvas to draw on
  var svg_heatmap = d3.select("#visualization_1").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var userLevel = ["Ultra Nerd",
                  "Technically Savvy",
                  "Average User",
                  "Luddite"]

  var userAttitude = ["Scared as hell",
                      "A little wary",
                      "On the fence",
                      "Cautiously optimistic",
                      "Super excited!"]

  // Build X scales and axis:
  var x = d3.scaleBand()
    .range([ 0, width ])
    .domain(userAttitude)
    .padding(0.01);
  svg_heatmap.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))

  // Build Y scales and axis:
  var y = d3.scaleBand()
    .range([ height, 0 ])
    .domain(userLevel)
    .padding(0.01);
  svg_heatmap.append("g")
    .call(d3.axisLeft(y));

  // Read the data
  d3.csv("preprocessed_data/user_categories.csv", function(data) {
    // Loop through the data and convert the numeric columns to numbers
    data.forEach(function(d){
      d.counts = +d.counts;
    })

    // create a tooltip
    var tooltip_heatmap = d3.select("#visualization_1")
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "1px")
      .style("border-radius", "5px")
      .style("padding", "5px")
      .style("width", "80px")
      .style("height", "60px")
      .style("position", "absolute")

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseover = function(d) {
      tooltip_heatmap.style("opacity", 1)
      d3.select(this)
        .style("stroke", "black")
        .style("opacity", 1)
    }
    var mousemove = function(d) {
      tooltip_heatmap
        .html(d.counts + " users")
        .style("left", (d3.mouse(this)[0]+50) + "px")
        .style("top", (d3.mouse(this)[1]+150) + "px")
    }
    var mouseleave = function(d) {
      tooltip_heatmap.style("opacity", 0)
      d3.select(this)
        .style("stroke", "none")
        .style("opacity", 0.8)
    }

    var max_counts = d3.max(data, function(d) { return d.counts; });

    // Build color scale
    var myColor = d3.scaleSequential()
      .interpolator(d3.interpolate("white", "#2a5674"))
      .domain([1, max_counts]);

    svg_heatmap.selectAll()
        .data(data, function(d) {return d.attitude+':'+d.user_level;})
        .enter()
        .append("rect")
        .attr("x", function(d) { return x(d.attitude) })
        .attr("y", function(d) { return y(d.user_level) })
        .attr("rx", 4)
        .attr("ry", 4)
        .attr("width", x.bandwidth() )
        .attr("height", y.bandwidth() )
        .style("fill", function(d) { return myColor(d.counts)} )
        .attr("class", function(d) { return createClassName(d.user_level, d.attitude) })
        .style("stroke-width", 4)
        .style("stroke", "none")
        .style("opacity", 0.8)
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)
        .on("click", click);
  })

  // VISUALIZATION 2: BARPLOT
  // Set up the bounds of the visualization
  var margin = { top: 20, right: 20, bottom: 120, left: 100 };
  var width = 960 - margin.right - margin.left;
  var height = 500 - margin.top - margin.bottom;

  // Set up the second SVG that gives us a canvas to draw on
  var svg_barplot = d3.select("#visualization_2").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Read the data
  d3.csv("preprocessed_data/devices_per_user_category.csv", addTotals, function(data) {
    // Loop through the data and convert the numeric columns to numbers
    var numeric_columns = JSON.parse(JSON.stringify(data.columns));
    numeric_columns.shift()

    data.forEach(function(d){
      numeric_columns.forEach(function(c){
        d[c] = +d[c];
      })
    })

    console.log(data.columns);

    // List of subgroups = header of the csv files = soil condition here
    var subgroups = data.columns.slice(1);

    // List of groups = species here = value of the first column called group -> I show them on the X axis
    var groups = d3.map(data, function(d){return(d.device)}).keys();

    // Add X axis
    var x = d3.scaleBand()
        .domain(groups)
        .range([0, width])
        .padding([0.2])
    svg_barplot.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x).tickSizeOuter(0))
      .selectAll("text")
        .attr("transform", "translate(-10,0)rotate(-45)")
        .style("text-anchor", "end");

    // Add Y axis
    var y = d3.scaleLinear()
      .range([ height, 0 ]);

    var tooltip_barplot = d3.select("#visualization_2")
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "1px")
      .style("border-radius", "5px")
      .style("padding", "5px")
      .style("position", "absolute")

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseover_bar = function(d) {
      if (typeof selectedClass != 'undefined') {
        var subgroupName = d3.select(this.parentNode).datum().key;
        if (fixClassName(subgroupName) == selectedClass) {
          var subgroupValue = d.data[subgroupName];
          tooltip_barplot
              .html("subgroup: " + subgroupName + "<br>" + "Value: " + subgroupValue)
              .style("opacity", 1)
        }
      }
    }
    var mousemove_bar = function(d) {
      tooltip_barplot
        .style("left", (d3.mouse(this)[0]+50) + "px")
        .style("top", (d3.mouse(this)[1]+750) + "px")
    }
    var mouseleave_bar = function(d) {
      tooltip_barplot
        .style("opacity", 0)
    }

    // color palette = one color per subgroup
    var color = d3.scaleOrdinal()
      .domain(subgroups)
      .range(["#88CCEE","#CC6677","#DDCC77","#117733",
              "#332288","#AA4499","#44AA99","#999933",
              "#882255","#661100","#6699CC","#888888",
              "#66C5CC","#F6CF71","#F89C74","#DCB0F2"])

    //stack the data? --> stack per subgroup
    var stackedData = d3.stack()
      .keys(subgroups)
      (data)

    // Set the domain for the y axis and append axis
    y.domain([0, d3.max(data, function(d) { return d.total; })]);
    svg_barplot.append("g")
      .call(d3.axisLeft(y));

    // Show the bars
    svg_barplot.append("g")
      .selectAll("g")
      // Enter in the stack data = loop key per key = group per group
      .data(stackedData)
      .enter().append("g")
        // // Option 1: Only one color for all the bars
        // .attr("fill", "#CC6677")
        // Option 2: A different color for each layer of the stacks.
        .attr("fill", function(d) { return color(d.key); })
        .attr("class", function(d){ return "bar-rect " + fixClassName(d.key) })
        .selectAll("rect")
        // enter a second time = loop subgroup per subgroup to add all rectangles
        .data(function(d) { return d; })
        .enter().append("rect")
          .attr("x", function(d) { return x(d.data.device); })
          .attr("y", function(d) { return y(d[1]); })
          .attr("height", function(d) { return y(d[0]) - y(d[1]); })
          .attr("width", x.bandwidth())
        .on("mouseover", mouseover_bar)
        .on("mousemove", mousemove_bar)
        .on("mouseleave", mouseleave_bar);
    })

function addTotals(d, i, columns) {
  for (i = 1, t = 0; i < columns.length; ++i) {
    t += d[columns[i]] = +d[columns[i]];
  }
  d.total = t;
  return d;
}

// With click, set a class that will be used in the second visualization.
function click() {
  if (typeof selectedClass == 'undefined') {
    selectedClass = this.className.baseVal;
    // Reduce opacity of all rect to 0.2
    d3.selectAll(".bar-rect").style("opacity", 0.2)
    // Highlight all rects of this subgroup with opacity 0.8. It is possible to select them since they have a specific class = their name.
    d3.selectAll("."+selectedClass)
      .style("opacity", 1)
  } else if (selectedClass == this.className.baseVal) {
    selectedClass = undefined;
    d3.selectAll(".bar-rect").style("opacity", 1);
  } else {
    selectedClass = this.className.baseVal;

    // Reduce opacity of all rect to 0.2
    d3.selectAll(".bar-rect").style("opacity", 0.2)
    // Highlight all rects of this subgroup with opacity 0.8. It is possible to select them since they have a specific class = their name.
    d3.selectAll("."+selectedClass)
      .style("opacity", 1)
  }
}

// Function for creating heatmap class names
function createClassName(level, attitude){
  var class_name = level + "_" + attitude;
  return class_name.replace(/ /g, "_").replace("!", "");
}

// Function to remove spaces from class names
function fixClassName(className){
  return className.replace(" x", "").replace(/ /g, "_").replace("!", "");
}

</script>
