
<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
  font: 10px sans-serif;
}

svg {
    display: block;
    margin: 0 auto;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.dot {
  stroke: #000;
}

.bar text {
  fill: #000;
  font: 10px sans-serif;
}

/*CSS for tooltip with a shadow*/
/*source: https://bl.ocks.org/sarubenfeld/56dc691df199b4055d90e66b9d5fc0d2*/

div.tooltip {
  position: absolute;
  width: 80px;
  text-align: center; 
  padding: 10px;
  background-color: white;
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
  -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
  box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
  pointer-events: none;
}
</style>
<body>
	<h2 style="text-align: center;">bar title</h2>
</body>
<!--Import the D3 Library (version 4 in this case)-->
<script src="https://d3js.org/d3.v4.min.js"></script>
<!--Source: https://bl.ocks.org/sebg/6f7f1dd55e0c52ce5ee0dac2b2769f4b-->
<script>

// references: ....................
// creating hist obj 
// source: https://bl.ocks.org/santiagogaray/e203193d9a8ba21be9a25b797880ac71

// ....................

// Set up the bounds of the visualization
var margine = {top: 20, right:20, bottom:50, left:40}; 
var width = 960 - margine.right - margine.left; 
var height = 600 - margine.top - margine.bottom; 

// Set up the scales (the pieces that will convert from the data to the screen)
var x = d3.scaleLinear()
		  // .domain([1960, 2010])
		  .range([0, width]);  

var y = d3.scaleLinear()
		  .range([height, 0]);      // the (0,0) is upper left corner 


// var color = d3.scaleSequential(d3.interpolateSpectral); 
var color = d3.scaleSequential(d3.interpolateMagma); 

// Set up the scaffolds
var xAxis = d3.axisBottom(x)
			  .tickFormat(d3.format("d")); 
var yAxis = d3.axisLeft(y); 

var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

// Set up an SVG that gives us a canvas to draw on
var svg = d3.select("body").append("svg")
			.attr("width", width + margine.left + margine.right)
			.attr("height", height + margine.top + margine.bottom) 
		  .append("g")
			.attr("transform","translate("+ margine.left + "," + margine.right + ")");


var formatCount = d3.format(",.0f");

// create a tooltip 
// source: https://bl.ocks.org/sarubenfeld/56dc691df199b4055d90e66b9d5fc0d2
var tooltip = d3.select("body").append("div")
								.attr("class", "tooltip")
								.style("opacity", 0); 



var user_level = "Average User";
var attribute = "A little wary";

var dataArray = [23, 13, 21, 14, 37, 15, 18, 34, 30];

svg.selectAll("rect")
	.data(dataArray)
	.enter().append("rect")
	.attr("height", function(d, i) {return (d * 10)})
	.attr("width", "40")
	.attr("x", function(d, i) {return (i * 60) + 25})
	.attr("y", function(d, i) {return 400 - (d * 10)});


// Import the data. Most of the drawing code goes in here.
// d3.csv("preprocessed_data/devices_per_user_category.csv", function(error, data) {
// 	if (error) throw error;

// 	data.forEach(function(d){
// 		d["WiFi router"] = +d["WiFi router"];  
// 	}); 

// 	var xMin = d3.min(data, function(d){return d["WiFi router"]}); 
// 	var xMax = d3.max(data, function(d){return d["WiFi router"]}); 
// 	x.domain([xMin, xMax]).nice(); 


// 	// create a histgram 
// 	// https://bl.ocks.org/santiagogaray/e203193d9a8ba21be9a25b797880ac71
// 	var histogram = d3.histogram()
// 					.value(function(d) { return d.Year; })
// 					.domain(x.domain())
// 					.thresholds(10); 
	
// 	var bins = histogram(data); 

// 	var yMin = 0; 
// 	var yMax = d3.max(bins, function(d){return d.length}); 
// 	y.domain([yMin, d3.max(bins, function(d){ return d.length; })]); 

// 	// color of the bar chart 
// 	var color = "steelblue";
// 	// create x axis 
// 	svg.append("g")
// 		.attr("class", "x axis")
// 		.attr("transform", "translate(0," + height + ")")
// 		.call(xAxis); 

// 	 svg.append("text")
//             .attr("text-anchor", "middle") 
//             .attr("transform", "translate("+ (width/2) +","+(height+(35))+")") 
//             .text("Year");

// 	// create y axis 
// 	svg.append("g")
// 	   .attr("class", "y axis")
// 	   .call(yAxis)

// 	svg.append("text")
//             .attr("text-anchor", "middle")  
//             .attr("transform", "translate("+ (-25) +","+(height/2)+")rotate(-90)") 
//             .text("Count");

//    	var div = d3.select("body").append("div")
// 		.attr("class", "tooltip")
// 		.style("opacity", 0);

// 	// add bar for each 
// 	var bar = svg.selectAll(".bar")
// 	 		.data(bins)
// 		.enter().append("g")
// 			.attr("class", "bar")
// 			.attr("transform", function(d) {
// 				return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })


// 	//// adding text to each bar 
// 	// bar.append("text") 
// 	// 	// .attr("dy", ".em")
// 	// 	.attr("y", 0)
// 	// 	.attr("x", (x(bins[0].x1) - x(bins[0].x0)) / 2)
// 	// 	.attr("id", function(d, i){return i;})
// 	// 	.attr("text-anchor", "middle")
// 	// 	.attr("class", "text")
// 	// 	.text(function(d) { return formatCount(d.length); })
// 	// 	.style("opacity", 1)
// 	// 	.attr('font-size', 15);

// 	// create bar charts 
// 	bar.append("rect")
// 			.attr("x", 1)
// 			.attr("width", function(d) { return x(d.x1) - x(d.x0) - 1.5; })
// 			.attr("height", function(d) { return height - y(d.length); })
// 			.attr("fill", function(d) { 
// 				if( d.length == yMax){
// 					return d3.rgb(color).darker(1);
// 				} else {
// 					return d3.rgb(color).brighter(1);
// 				}
// 	  		})
// 		  	.on("mouseover", function(d){

// 		  		// show the tooltip 
// 				tooltip.transition()
// 						.duration(500)
// 						.style("opacity", 1); 

// 				// contents of the tooltip 
// 				tooltip.html(d.x0 + " - " + d.x1 + ": " + d.length)
// 						.style("left", (d3.event.pageX) + "px") 
// 						.style("top", (d3.event.pageY) + "px"); 

// 	  		})
// 		  	.on("mouseout", function(d){
// 	  				d3.select(this)
// 			  		.transition()
//               		.duration(550)
//               		.attr("fill", function(d) { 
//               			// change the color back when the mouseis out 
// 						return (d.length == yMax) ? d3.rgb(color).darker(1): d3.rgb(color).brighter(1);
// 					}); 

//               		// hide tooltops 
// 					tooltip.transition()
// 						.duration(500)
// 						.style("opacity", 0); 
//              });	
// }); 


</script>
